#pragma once
/*
 * This file was generated by ClangActiveObjectGenerator
 */

{{#Includes}}
#include "{{InterfaceHeaderFileName}}"
#include <memory>
{{/Includes}}

{{#Class}}
template <class TExecutor>
class {{InterfaceImplName}} : public {{InterfaceName}} {
public:
  {{InterfaceImplName}}(const std::shared_ptr<{{InterfaceName}}>& impl, TExecutor& executor)
      : m_impl(impl)
      , m_executor(executor)
  {
  }

public: // {{InterfaceName}}
    {{#Methods}}
    {{Signature}} override {
        m_executor.post(
            [this, {{Parameters}}](){
                m_impl.lock()->{{FunctionCall}};
            });
    }

    {{/Methods}}

private:
   std::weak_ptr<{{InterfaceName}}> m_impl;
   TExecutor& m_executor;
};

#ifndef MAKE_ACTIVE_OBJECT
#define MAKE_ACTIVE_OBJECT
template <class TInterface, class TExecutor>
class MakeActiveObject {};

template <class TInterface, class TExecutor>
std::unique_ptr<TInterface>
make_active_object(const std::shared_ptr<TInterface>& impl, TExecutor& executor)
{
    return MakeActiveObject<TInterface, TExecutor>{}(impl, executor);
}
#endif

template <class TExecutor>
class MakeActiveObject<{{InterfaceName}}, TExecutor> {
public:
    std::unique_ptr<{{InterfaceName}}> operator()(const std::shared_ptr<{{InterfaceName}}>& impl, TExecutor& executor){
            return std::make_unique<{{InterfaceImplName}}<TExecutor>>(impl, executor);
    }
};
{{/Class}}